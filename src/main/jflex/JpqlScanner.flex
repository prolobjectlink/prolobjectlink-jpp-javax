/*
 * #%L
 * prolobjectlink-db
 * %%
 * Copyright (C) 2019 Prolobjectlink Project
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

package org.logicware.database.querylang.jpql;

import java.io.IOException;
import java.io.StringReader;

import org.logicware.database.ql.Scanner;
import org.logicware.database.ql.SymbolEntry;
import org.logicware.database.ql.SymbolTable;
import org.logicware.logging.LoggerConstants;
import org.logicware.logging.LoggerUtils;

/**
 * This class is a scanner generated by 
 * <a href="http://www.jflex.de/">JFlex</a> 1.6.0
 * from the specification file 
 * <tt>${basedir}/src/main/jflex/JpqlScanner.flex</tt>
 */
 
%%

%char
%line
%column
%unicode

%public
%class JpqlScanner
%extends JpqlSymbols
%implements Scanner
%type SymbolEntry
%function getNextToken

%{ 

  SymbolTable symtab;
  StringBuffer string = new StringBuffer();
  
  public JpqlScanner(StringReader jpqlReader, SymbolTable table) {
		this(jpqlReader);
		symtab = table;
	}

   public void setSymtab(SymbolTable symtab) {
    this.symtab = symtab; 
  }

  private SymbolEntry sym(int type) {
		return new SymbolEntry(type, yyline + 1, yycolumn + 1);
	}

	private SymbolEntry sym(int type, Object value) {
		return new SymbolEntry(type, yyline + 1, yycolumn + 1, value);
	}
	
	public boolean hasNext() {
		try {
			return getNextToken().sym != EOF;
		} catch (IOException e) {
			LoggerUtils.error(getClass(), LoggerConstants.IO, e);
		}
		return false;
	}

	public SymbolEntry next() {
		try {
			return getNextToken();
		} catch (IOException e) {
			LoggerUtils.error(getClass(), LoggerConstants.IO, e);
		}
		return null;
	}
	
	private long parseLong(int start, int end, int radix) {
		long result = 0;
		long digit;

		for (int i = start; i < end; i++) {
		  digit  = Character.digit(yycharat(i),radix);
		  result*= radix;
		  result+= digit;
		}
		return result;
  }
	
	
%}




/* main character classes */
LineTerminator = \r|\n|\r\n
InputCharacter = [^\r\n]

WhiteSpace = {LineTerminator} | [ \t\f]

/* comments */
Comment = {TraditionalComment} | {EndOfLineComment} | 
          {DocumentationComment}

TraditionalComment = "/*" [^*] ~"*/" | "/*" "*"+ "/"
EndOfLineComment = "//" {InputCharacter}* {LineTerminator}?
DocumentationComment = "/*" "*"+ [^/*] ~"*/"

/* identifiers */
Identifier = [:jletter:][:jletterdigit:]*

/* integer literals */
DecIntegerLiteral = 0 | [1-9][0-9]*
DecLongLiteral    = {DecIntegerLiteral} [lL]

HexIntegerLiteral = 0 [xX] 0* {HexDigit} {1,8}
HexLongLiteral    = 0 [xX] 0* {HexDigit} {1,16} [lL]
HexDigit          = [0-9a-fA-F]

OctIntegerLiteral = 0+ [1-3]? {OctDigit} {1,15}
OctLongLiteral    = 0+ 1? {OctDigit} {1,21} [lL]
OctDigit          = [0-7]
    
/* floating point literals */        
FloatLiteral  = ({FLit1}|{FLit2}|{FLit3}) {Exponent}? [fF]
DoubleLiteral = ({FLit1}|{FLit2}|{FLit3}) {Exponent}?

FLit1    = [0-9]+ \. [0-9]* 
FLit2    = \. [0-9]+ 
FLit3    = [0-9]+ 
Exponent = [eE] [+-]? [0-9]+

/* string and character literals */
StringCharacter = [^\r\n\"\\]
SingleCharacter = [^\r\n\'\\]

%state STRING, CHARLITERAL

%%
 
<YYINITIAL> { 

"FUNCTION"       { return sym(FUNCTION); }
"END"            { return sym(END); }

// case
"CASE"           { return sym(CASE); }
"WHEN"           { return sym(WHEN); }
"THEN"           { return sym(THEN); }
"ELSE"           { return sym(ELSE); }
"COALESCE"       { return sym(COALESCE); }
"NULLIF"         { return sym(NULLIF); }

// boolean operators
"OR"           	{ return sym(OR); }
"AND"           { return sym(AND); }
"NOT"           { return sym(NOT); }

// statements
"SELECT"        { return sym(SELECT); }
"DELETE"        { return sym(DELETE); }
"UPDATE"        { return sym(UPDATE); }

// statements conditions
"DISTINCT"       { return sym(DISTINCT); }
"FROM"           { return sym(FROM); }
"WHERE"          { return sym(WHERE); }
"GROUP"          { return sym(GROUP); }
"BY"           	 { return sym(BY); }
"HAVING"         { return sym(HAVING); }
"ORDER"          { return sym(ORDER); }
"AS"           	 { return sym(AS); }
"SET"            { return sym(SET); }
"ASC"            { return sym(ASC); }
"DESC"           { return sym(DESC); }

// object
"OBJECT"         { return sym(OBJECT); }
"NEW"            { return sym(NEW); }
"TREAT"          { return sym(TREAT); }
"ENTRY"          { return sym(ENTRY); }
"KEY"            { return sym(KEY); }
"VALUE"          { return sym(VALUE); }

// 
"BETWEEN"       { return sym(BETWEEN); }
"LIKE"          { return sym(LIKE); }
"ALL"           { return sym(ALL); }
"ANY"           { return sym(ANY); }
"SOME"          { return sym(SOME); }
"ESCAPE"        { return sym(ESCAPE); }
"IS"            { return sym(IS); }
"EMPTY"         { return sym(EMPTY); }
"MEMBER"        { return sym(MEMBER); }
"OF"            { return sym(OF); }
"EXISTS"        { return sym(EXISTS); }
"TYPE"          { return sym(TYPE); }
"IN"            { return sym(IN); }

// string functions
"LENGTH"           { return sym(LENGTH); }
"LOCATE"           { return sym(LOCATE); }
"SIZE"             { return sym(SIZE); }
"INDEX"            { return sym(INDEX); }
"COUNT"            { return sym(COUNT); }
"CONCAT"           { return sym(CONCAT); }
"SUBSTRING"        { return sym(SUBSTRING); }
"TRIM"             { return sym(TRIM); }
"LOWER"            { return sym(LOWER); }
"UPPER"            { return sym(UPPER); }

// date-time functions
"CURRENT_DATE"           { return sym(CURRENT_DATE); }
"CURRENT_TIME"           { return sym(CURRENT_TIME); }
"CURRENT_TIMESTAMP"      { return sym(CURRENT_TIMESTAMP); }

// trim specification
"LEADING"           { return sym(LEADING); }
"TRAILING"           { return sym(TRAILING); }
"BOTH"           { return sym(BOTH); }

// numeric functions
"AVG"           { return sym(AVG); }
"SUM"           { return sym(SUM); }
"MAX"           { return sym(MAX); }
"MIN"           { return sym(MIN); }
"ABS"           { return sym(ABS); }
"MOD"           { return sym(MOD); }
"SQRT"          { return sym(SQRT); }

// joins
"FETCH"         { return sym(FETCH); }
"LEFT"          { return sym(LEFT); }
"INNER"         { return sym(INNER); }
"OUTER"         { return sym(OUTER); }
"JOIN"          { return sym(JOIN); }
"ON"            { return sym(ON); }

// data types
//terminal String ID, NUMBER,  STRING, POSITIVE, DATE, TIMESTAMP, NULL;
//terminal Character CHAR, UNDERSCORE, PERCENT;
//terminal Boolean TRUE, FALSE;

// entity [A-Z].[a-zA-Z]*
//terminal ENTITY;

// separators
"."             	{ return sym(DOT); }
":"         		{ return sym(COLON); }
","             	{ return sym(COMMA); }
"("             	{ return sym(LPAR); }
")"             	{ return sym(RPAR); }
"?"      			{ return sym(QUESTION); }
    
// arithmetics operators
"-"             	{ return sym(MINUS); }
"+"             	{ return sym(PLUS); }
"*"             	{ return sym(TIMES); }
"/"             	{ return sym(DIV); }

// comparison operators
"="             	{ return sym(EQ); }
"<"             	{ return sym(LE); }
"<="            	{ return sym(LEQ); }
">"             	{ return sym(GT); }
"=>"            	{ return sym(GEQ); }
"<>"            	{ return sym(UNEQ); }

/* string literal */
  \"                             { yybegin(STRING); string.setLength(0); }

  /* character literal */
  \'                             { yybegin(CHARLITERAL); }

  /* numeric literals */
  "-2147483648"                  { return sym(INTEGER_LITERAL, new Integer(Integer.MIN_VALUE)); }
  
  {DecIntegerLiteral}            { return sym(INTEGER_LITERAL, new Integer(yytext())); }
  {DecLongLiteral}               { return sym(INTEGER_LITERAL, new Long(yytext().substring(0,yylength()-1))); }
  
  {HexIntegerLiteral}            { return sym(INTEGER_LITERAL, new Integer((int) parseLong(2, yylength(), 16))); }
  {HexLongLiteral}               { return sym(INTEGER_LITERAL, new Long(parseLong(2, yylength()-1, 16))); }
 
  {OctIntegerLiteral}            { return sym(INTEGER_LITERAL, new Integer((int) parseLong(0, yylength(), 8))); }  
  {OctLongLiteral}               { return sym(INTEGER_LITERAL, new Long(parseLong(0, yylength()-1, 8))); }
  
  {FloatLiteral}                 { return sym(FLOATING_POINT_LITERAL, new Float(yytext().substring(0,yylength()-1))); }
  {DoubleLiteral}                { return sym(FLOATING_POINT_LITERAL, new Double(yytext())); }
  {DoubleLiteral}[dD]            { return sym(FLOATING_POINT_LITERAL, new Double(yytext().substring(0,yylength()-1))); }
  
  /* comments */
  {Comment}                      { /* ignore */ }

  /* whitespace */
  {WhiteSpace}                   { /* ignore */ }

  /* identifiers */ 
  {Identifier}                   { return sym(IDENTIFIER, yytext()); }  
}

<STRING> {
  \"                             { yybegin(YYINITIAL); return sym(STRING_LITERAL, string.toString()); }
  
  {StringCharacter}+             { string.append( yytext() ); }
  
  /* escape sequences */
  "\\b"                          { string.append( '\b' ); }
  "\\t"                          { string.append( '\t' ); }
  "\\n"                          { string.append( '\n' ); }
  "\\f"                          { string.append( '\f' ); }
  "\\r"                          { string.append( '\r' ); }
  "\\\""                         { string.append( '\"' ); }
  "\\'"                          { string.append( '\'' ); }
  "\\\\"                         { string.append( '\\' ); }
  \\[0-3]?{OctDigit}?{OctDigit}  { char val = (char) Integer.parseInt(yytext().substring(1),8);
                        				   string.append( val ); }
  
  /* error cases */
  \\.                            { throw new RuntimeException("Illegal escape sequence \""+yytext()+"\""); }
  {LineTerminator}               { throw new RuntimeException("Unterminated string at end of line"); }
}

<CHARLITERAL> {
  {SingleCharacter}\'            { yybegin(YYINITIAL); return sym(CHARACTER_LITERAL, new Character(yytext().charAt(0))); }
  
  /* escape sequences */
  "\\b"\'                        { yybegin(YYINITIAL); return sym(CHARACTER_LITERAL, new Character('\b'));}
  "\\t"\'                        { yybegin(YYINITIAL); return sym(CHARACTER_LITERAL, new Character('\t'));}
  "\\n"\'                        { yybegin(YYINITIAL); return sym(CHARACTER_LITERAL, new Character('\n'));}
  "\\f"\'                        { yybegin(YYINITIAL); return sym(CHARACTER_LITERAL, new Character('\f'));}
  "\\r"\'                        { yybegin(YYINITIAL); return sym(CHARACTER_LITERAL, new Character('\r'));}
  "\\\""\'                       { yybegin(YYINITIAL); return sym(CHARACTER_LITERAL, new Character('\"'));}
  "\\'"\'                        { yybegin(YYINITIAL); return sym(CHARACTER_LITERAL, new Character('\''));}
  "\\\\"\'                       { yybegin(YYINITIAL); return sym(CHARACTER_LITERAL, new Character('\\')); }
  \\[0-3]?{OctDigit}?{OctDigit}\' { yybegin(YYINITIAL); 
			                              int val = Integer.parseInt(yytext().substring(1,yylength()-1),8);
			                            return sym(CHARACTER_LITERAL, new Character((char)val)); }
  
  /* error cases */
  \\.                            { throw new RuntimeException("Illegal escape sequence \""+yytext()+"\""); }
  {LineTerminator}               { throw new RuntimeException("Unterminated character literal at end of line"); }
}

/* error fallback */
.|\n                             { throw new RuntimeException("Illegal character \""+yytext()+
                                                              "\" at line "+yyline+", column "+yycolumn); }
<<EOF>>                          { return sym(EOF); }
